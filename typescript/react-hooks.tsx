import React, {
  useState,
  useEffect,
  useCallback,
  useMemo,
  useRef,
  useReducer,
  Reducer,
} from "react";
import { Expect, Equal } from "../utils/types-utils";

// useState typing
type Tag = {
  id: number;
  value: string;
};

export const SimpleTags = () => {
  const [tags, setTags] = useState<Tag[]>([]);
  return (
    <div>
      {tags.map((tag) => {
        return <div key={tag.id}>{tag.value}</div>;
      })}
      <button
        onClick={() => {
          setTags([
            ...tags,
            {
              id: new Date().getTime(),
              value: "New",
            },
          ]);
        }}
      >
        Add Tag
      </button>
    </div>
  );
};

// useState with interface
interface Data {
  id: number;
  name: string;
}

const fetchData = () => {
  return Promise.resolve({ id: 1, name: "John" });
};

export const Component = () => {
  const [data, setData] = useState<Data | undefined>();

  useEffect(() => {
    fetchData().then((val) => {
      setData(val);
    });
  }, []);
};

// nested states
interface TagState {
  tagSelected: number | null;
  tags: { id: number; value: string }[];
}

// creating an object of type TageState will force you to use only the properties specified in that type
const tagState: TagState = {
  tagSelected: 1,
  tags: [],
};

/* 

but creating a function type will not. This has to do with covariance and contravariance: 
https://medium.com/@codeoz/how-i-understand-covariance-contravariance-in-typescript-cb790769660e

*/

type GetTageState = () => TagState;

const getTagState: GetTageState = () => ({
  tagSelected: 1,
  tags: [],
  anyOtherValue: 0,
});

// we fix this by tagging the function itself, saying this function returns this:
const getTagStateTagged: GetTageState = (): TagState => ({
  tagSelected: 1,
  tags: [],
  /* @ts-expect-error */
  anyOtherValue: 0,
});

export const NestedTags = () => {
  const [state, setState] = useState<TagState>({
    tags: [],
    tagSelected: null,
  });
  return (
    <div>
      {state.tags.map((tag) => {
        return (
          <button
            key={tag.id}
            onClick={() => {
              setState(
                (currentState): TagState => ({
                  ...currentState,
                  // @ts-expect-error
                  tagselected: tag.id,
                })
              );
            }}
          >
            {tag.value}
          </button>
        );
      })}
      <button
        onClick={() => {
          setState(
            (currentState): TagState => ({
              ...currentState,
              tags: [
                ...currentState.tags,
                {
                  id: new Date().getTime(),
                  value: "New",
                  // @ts-expect-error
                  otherValue: "something",
                },
              ],
            })
          );
        }}
      >
        Add Tag
      </button>
    </div>
  );
};

// useEffect expect a return of void or Destructor so returning anything else will give us this error
export const useTimeout = (timerMs: number) => {
  useEffect(
    () =>
      // @ts-expect-error
      setTimeout(() => {
        console.log("Done!");
      }, timerMs),
    [timerMs]
  );
};

// the correct way with a destructor return
export const useTimeoutCorrected = (timerMs: number) => {
  useEffect(() => {
    const timeOut = setTimeout(() => {
      console.log("Done!");
    }, timerMs);
    return () => {
      clearTimeout(timeOut);
    };
  }, [timerMs]);
};

// useCallback
export const Buttons = (props: { id: string }) => {
  const onClick = useCallback(
    (buttonName: string) => {
      console.log(props.id, buttonName);
    },
    [props.id]
  );
};

// useMemo can infer the type from the return of the callback
export const MemoComponent = () => {
  const autoGeneratedIds = useMemo(() => {
    // generate 100 random string uuid's
    return Array.from({ length: 100 }, () =>
      Math.random().toString(36).substr(2, 9)
    );
  }, []);
};

// but we can also explicitly declare to make sure we don't get any additional properties in the case of objects
type MemoType = {
  key: number;
  value: string;
};
// this doesn't work
export const MemoObjectComponentIncorrect = () => {
  const autoGeneratedIds = useMemo<MemoType>(() => {
    return {
      key: 1,
      value: "text",
      valueNotInType: true,
    };
  }, []);
};
// but this does
export const MemoObjectComponentCorrect = () => {
  const autoGeneratedIds = useMemo((): MemoType => {
    return {
      key: 1,
      value: "text",
      // @ts-expect-error
      valueNotInType: true,
    };
  }, []);
};

// useRef
export const RefComponent = () => {
  const id = useRef<string>();

  useEffect(() => {
    id.current = "Random value!";
  }, []);

  return <div></div>;
};

export const nullAsRef = (
  <div
    ref={{
      current: null,
    }}
  ></div>
);

// Legacy refs are supported!
export const stringAsRef = <div ref={"legacyRef"}></div>;

export const undefinedAsRef = (
  <div
    ref={{
      // Type 'undefined' is not assignable to
      // type 'HTMLDivElement | null'.
      // @ts-expect-error
      current: undefined,
    }}
  ></div>
);

// Callback refs are supported via RefCallback<T>
export const callbackRefs = (
  <div
    ref={(htmlDivElement) => {
      type test = Expect<Equal<typeof htmlDivElement, HTMLDivElement | null>>;
    }}
  ></div>
);

export const ComponentNull = () => {
  const ref = useRef<HTMLDivElement>(null);

  return <div ref={ref} />;
};

// useRef overloads examples
export const RefOverloadsComponent = () => {
  // first overload returns a mutable object
  const firstOverload = useRef<string>("124123123");
  firstOverload.current = "123j12jhb123jhb";

  // second returns a readonly object
  const secondOverload = useRef<string>(null);
  secondOverload.current;

  // third return a mutable object or undefined
  const thirdOverload = useRef<string>();
  thirdOverload.current = "hello";

  return null;
};

// Discriminated union types with reducer
type StateType = {
  count: number;
};

type ActionType =
  | {
      type: "add";
      add: number;
    }
  | {
      type: "subtract";
      subtract: number;
    };

// manually typing the reducer
const reducer = (state: StateType, action: ActionType): StateType => {
  switch (action.type) {
    case "add":
      return { count: state.count + action.add };
    case "subtract":
      return { count: state.count - action.subtract };
    default:
      throw new Error();
  }
};

//using React's Reducer type
const reducerReducer: Reducer<StateType, ActionType> = (state, action) => {
  switch (action.type) {
    case "add":
      return { count: state.count + action.add };
    case "subtract":
      return { count: state.count - action.subtract };
    default:
      throw new Error();
  }
};

const [state, dispatch] = useReducer(reducer, { count: 0 });

type tests = [Expect<Equal<typeof state.count, number>>];

dispatch({ type: "add", add: 1 });

// @ts-expect-error
dispatch({ type: "SUBTRACT", subtract: 1 });

// @ts-expect-error
dispatch({ type: "add" });

// @ts-expect-error
dispatch({ type: "subtract", subtract: "123" });
